知乎上前人写的程序只能够将纯文本回封cst，所以让大模型修改了一下程序，经过调试可以将带控制符号的txt回封cst。
但要注意的是txt必须使用GBK编码，不要想着用UTF-8编码，因为很麻烦。
目前对程序的修改：
关于把80改成86
在Windows系统中，CreateFontA 函数用于创建一个指定字体的设备上下文（Device Context，DC）。
这个函数接受多个参数，其中一个参数是 lfCharSet，它指定了字体的字符集。字符集决定了字体如何解释和显示文本。
在Windows API中，字符集的值是一个整数，这个整数对应于特定的编码标准。例如：

0x80 对应于 Shift-JIS（SJIS）编码，这是日本的一种字符编码标准，用于表示日文字符。
0x86 对应于 GBK（国标扩展）编码，这是中国大陆的一种字符编码标准，用于表示简体中文字符。
在文章中提到的操作，将 CreateFontA 函数中的 lfCharSet 参数从 0x80 修改为 0x86，实际上是在告诉Windows使用GBK编码来创建字体，而不是SJIS编码。这样做的目的是为了让游戏能够正确显示简体中文字符，而不是日文字符。

在某些情况下，如果游戏或应用程序默认使用SJIS编码来显示中文，那么在简体中文环境下可能会出现乱码。通过修改这个值，可以确保游戏或应用程序使用正确的编码来显示中文，从而解决乱码问题。

在实际操作中，这通常涉及到使用调试工具（如OllyDbg，简称OD）来修改程序的内存中的值。在调试器中，你可以找到 CreateFontA 函数的调用，然后修改相应的参数值。这种方法需要一定的汇编语言和调试知识，以及对Windows API的了解。

关于把FC改成FE
GBK两个字节的编码范围都是0XA1-0XFE，就是161-254。
而Shift-JIS（SJIS）编码的范围0x80-0xFC，就是128-252。
改成0x86-0xFE，就是134-254。所以把FC改成FE就兼容GBK了

总之，一个是在告诉系统指定编码集，一个是在修改编码范围边界。

——都只是针对GBK编码显示的修改，而UTF-8是变长字符？要程序兼容UTF-8编码真的很麻烦，
除非说能够拿到源码，或者说程序原本就支持Unicode编码